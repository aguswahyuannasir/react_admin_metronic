{"ast":null,"code":"(function () {\n  var e = window.AmCharts;\n  e.AmSerialChart = e.Class({\n    inherits: e.AmRectangularChart,\n    construct: function (a) {\n      this.type = \"serial\";\n      e.AmSerialChart.base.construct.call(this, a);\n      this.cname = \"AmSerialChart\";\n      this.theme = a;\n      this.createEvents(\"changed\");\n      this.columnSpacing = 5;\n      this.columnSpacing3D = 0;\n      this.columnWidth = .8;\n      this.updateScrollbar = !0;\n      var b = new e.CategoryAxis(a);\n      b.chart = this;\n      this.categoryAxis = b;\n      this.zoomOutOnDataUpdate = !0;\n      this.mouseWheelZoomEnabled = this.mouseWheelScrollEnabled = this.rotate = this.skipZoom = !1;\n      this.minSelectedTime = 0;\n      e.applyTheme(this, a, this.cname);\n    },\n    initChart: function () {\n      e.AmSerialChart.base.initChart.call(this);\n      this.updateCategoryAxis(this.categoryAxis, this.rotate, \"categoryAxis\");\n      this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);\n      var a = this.chartCursor;\n      a && (a.updateData(), a.fullWidth && (a.fullRectSet = this.cursorLineSet));\n      var a = this.countColumns(),\n          b = this.graphs,\n          c;\n\n      for (c = 0; c < b.length; c++) b[c].columnCount = a;\n\n      this.updateScrollbar = !0;\n      this.drawChart();\n      this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins());\n    },\n    handleWheelReal: function (a, b) {\n      if (!this.wheelBusy) {\n        var c = this.categoryAxis,\n            d = c.parseDates,\n            g = c.minDuration(),\n            e = c = 1;\n        this.mouseWheelZoomEnabled ? b || (c = -1) : b && (c = -1);\n        var f = this.chartData.length,\n            m = this.lastTime,\n            l = this.firstTime;\n        0 > a ? d ? (f = this.endTime - this.startTime, d = this.startTime + c * g, g = this.endTime + e * g, 0 < e && 0 < c && g >= m && (g = m, d = m - f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && this.end >= f - 1 && (c = e = 0), d = this.start + c, g = this.end + e, this.zoomToIndexes(d, g)) : d ? (f = this.endTime - this.startTime, d = this.startTime - c * g, g = this.endTime - e * g, 0 < e && 0 < c && d <= l && (d = l, g = l + f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && 1 > this.start && (c = e = 0), d = this.start - c, g = this.end - e, this.zoomToIndexes(d, g));\n      }\n    },\n    validateData: function (a) {\n      this.marginsUpdated = !1;\n      this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN);\n      e.AmSerialChart.base.validateData.call(this);\n    },\n    drawChart: function () {\n      e.AmSerialChart.base.drawChart.call(this);\n      var a = this.chartData;\n\n      if (e.ifArray(a)) {\n        var b = this.chartScrollbar;\n        b && b.draw();\n\n        if (0 < this.realWidth && 0 < this.realHeight) {\n          var a = a.length - 1,\n              c,\n              b = this.categoryAxis;\n\n          if (b.parseDates && !b.equalSpacing) {\n            if (b = this.startTime, c = this.endTime, isNaN(b) || isNaN(c)) b = this.firstTime, c = this.lastTime;\n          } else if (b = this.start, c = this.end, isNaN(b) || isNaN(c)) b = 0, c = a;\n\n          this.endTime = this.startTime = this.end = this.start = void 0;\n          this.zoom(b, c);\n        }\n      } else this.cleanChart();\n\n      this.dispDUpd();\n      this.chartCreated = !0;\n    },\n    cleanChart: function () {\n      e.callMethod(\"destroy\", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor]);\n    },\n    updateCategoryAxis: function (a, b, c) {\n      a.chart = this;\n      a.id = c;\n      a.rotate = b;\n      a.axisRenderer = e.RecAxis;\n      a.guideFillRenderer = e.RecFill;\n      a.axisItemRenderer = e.RecItem;\n      a.setOrientation(!this.rotate);\n      a.x = this.marginLeftReal;\n      a.y = this.marginTopReal;\n      a.dx = this.dx;\n      a.dy = this.dy;\n      a.width = this.plotAreaWidth - 1;\n      a.height = this.plotAreaHeight - 1;\n      a.viW = this.plotAreaWidth - 1;\n      a.viH = this.plotAreaHeight - 1;\n      a.viX = this.marginLeftReal;\n      a.viY = this.marginTopReal;\n      a.marginsChanged = !0;\n    },\n    updateValueAxes: function () {\n      e.AmSerialChart.base.updateValueAxes.call(this);\n      var a = this.valueAxes,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            d = this.rotate;\n        c.rotate = d;\n        c.setOrientation(d);\n        d = this.categoryAxis;\n        if (!d.startOnAxis || d.parseDates) c.expandMinMax = !0;\n      }\n    },\n    updateData: function () {\n      this.parseData();\n      var a = this.graphs,\n          b,\n          c = this.chartData;\n\n      for (b = 0; b < a.length; b++) a[b].data = c;\n\n      0 < c.length && (this.firstTime = this.getStartTime(c[0].time), this.lastTime = this.getEndTime(c[c.length - 1].time));\n    },\n    getStartTime: function (a) {\n      var b = this.categoryAxis;\n      return e.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime();\n    },\n    getEndTime: function (a) {\n      var b = e.extractPeriod(this.categoryAxis.minPeriod);\n      return e.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1;\n    },\n    updateMargins: function () {\n      e.AmSerialChart.base.updateMargins.call(this);\n      var a = this.chartScrollbar;\n      a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate));\n    },\n    updateScrollbars: function () {\n      e.AmSerialChart.base.updateScrollbars.call(this);\n      this.updateChartScrollbar(this.chartScrollbar, this.rotate);\n    },\n    zoom: function (a, b) {\n      var c = this.categoryAxis;\n      c.parseDates && !c.equalSpacing ? this.timeZoom(a, b) : this.indexZoom(a, b);\n      this.updateLegendValues();\n    },\n    timeZoom: function (a, b) {\n      var c = this.maxSelectedTime;\n      isNaN(c) || (b != this.endTime && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.startTime && b - a > c && (b = a + c, this.updateScrollbar = !0));\n      var d = this.minSelectedTime;\n\n      if (0 < d && b - a < d) {\n        var g = Math.round(a + (b - a) / 2),\n            d = Math.round(d / 2);\n        a = g - d;\n        b = g + d;\n      }\n\n      var h = this.chartData,\n          g = this.categoryAxis;\n\n      if (e.ifArray(h) && (a != this.startTime || b != this.endTime)) {\n        var f = g.minDuration(),\n            d = this.firstTime,\n            m = this.lastTime;\n        a || (a = d, isNaN(c) || (a = m - c));\n        b || (b = m);\n        a > m && (a = m);\n        b < d && (b = d);\n        a < d && (a = d);\n        b > m && (b = m);\n        b < a && (b = a + f);\n        b - a < f / 5 && (b < m ? b = a + f / 5 : a = b - f / 5);\n        this.startTime = a;\n        this.endTime = b;\n        c = h.length - 1;\n        f = this.getClosestIndex(h, \"time\", a, !0, 0, c);\n        h = this.getClosestIndex(h, \"time\", b, !1, f, c);\n        g.timeZoom(a, b);\n        g.zoom(f, h);\n        this.start = e.fitToBounds(f, 0, c);\n        this.end = e.fitToBounds(h, 0, c);\n        this.zoomAxesAndGraphs();\n        this.zoomScrollbar();\n        a != d || b != m ? this.showZB(!0) : this.showZB(!1);\n        this.updateColumnsDepth();\n        this.dispatchTimeZoomEvent();\n      }\n    },\n    updateAfterValueZoom: function () {\n      this.zoomAxesAndGraphs();\n      this.zoomScrollbar();\n      this.updateColumnsDepth();\n    },\n    indexZoom: function (a, b) {\n      var c = this.maxSelectedSeries;\n      isNaN(c) || (b != this.end && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.start && b - a > c && (b = a + c, this.updateScrollbar = !0));\n\n      if (a != this.start || b != this.end) {\n        var d = this.chartData.length - 1;\n        isNaN(a) && (a = 0, isNaN(c) || (a = d - c));\n        isNaN(b) && (b = d);\n        b < a && (b = a);\n        b > d && (b = d);\n        a > d && (a = d - 1);\n        0 > a && (a = 0);\n        this.start = a;\n        this.end = b;\n        this.categoryAxis.zoom(a, b);\n        this.zoomAxesAndGraphs();\n        this.zoomScrollbar();\n        0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1);\n        this.updateColumnsDepth();\n        this.dispatchIndexZoomEvent();\n      }\n    },\n    updateGraphs: function () {\n      e.AmSerialChart.base.updateGraphs.call(this);\n      var a = this.graphs,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n        c.columnWidthReal = this.columnWidth;\n        c.categoryAxis = this.categoryAxis;\n        e.isString(c.fillToGraph) && (c.fillToGraph = this.getGraphById(c.fillToGraph));\n      }\n    },\n    updateColumnsDepth: function () {\n      var a,\n          b = this.graphs,\n          c;\n      e.remove(this.columnsSet);\n      this.columnsArray = [];\n\n      for (a = 0; a < b.length; a++) {\n        c = b[a];\n        var d = c.columnsArray;\n\n        if (d) {\n          var g;\n\n          for (g = 0; g < d.length; g++) this.columnsArray.push(d[g]);\n        }\n      }\n\n      this.columnsArray.sort(this.compareDepth);\n\n      if (0 < this.columnsArray.length) {\n        b = this.container.set();\n        this.columnSet.push(b);\n\n        for (a = 0; a < this.columnsArray.length; a++) b.push(this.columnsArray[a].column.set);\n\n        c && b.translate(c.x, c.y);\n        this.columnsSet = b;\n      }\n    },\n    compareDepth: function (a, b) {\n      return a.depth > b.depth ? 1 : -1;\n    },\n    zoomScrollbar: function () {\n      var a = this.chartScrollbar,\n          b = this.categoryAxis;\n      a && this.updateScrollbar && a.enabled && (a.dragger.stop(), b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end), this.updateScrollbar = !0);\n    },\n    updateTrendLines: function () {\n      var a = this.trendLines,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            c = e.processObject(c, e.TrendLine, this.theme);\n        a[b] = c;\n        c.chart = this;\n        c.id || (c.id = \"trendLineAuto\" + b + \"_\" + new Date().getTime());\n        e.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));\n        c.valueAxis || (c.valueAxis = this.valueAxes[0]);\n        c.categoryAxis = this.categoryAxis;\n      }\n    },\n    zoomAxesAndGraphs: function () {\n      if (!this.scrollbarOnly) {\n        var a = this.valueAxes,\n            b;\n\n        for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);\n\n        a = this.graphs;\n\n        for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);\n\n        this.zoomTrendLines();\n        (b = this.chartCursor) && b.zoom(this.start, this.end, this.startTime, this.endTime);\n      }\n    },\n    countColumns: function () {\n      var a = 0,\n          b = this.valueAxes.length,\n          c = this.graphs.length,\n          d,\n          e,\n          h = !1,\n          f,\n          m;\n\n      for (m = 0; m < b; m++) {\n        e = this.valueAxes[m];\n        var l = e.stackType;\n        if (\"100%\" == l || \"regular\" == l) for (h = !1, f = 0; f < c; f++) d = this.graphs[f], d.tcc = 1, d.valueAxis == e && \"column\" == d.type && (!h && d.stackable && (a++, h = !0), (!d.stackable && d.clustered || d.newStack) && a++, d.columnIndex = a - 1, d.clustered || (d.columnIndex = 0));\n\n        if (\"none\" == l || \"3d\" == l) {\n          h = !1;\n\n          for (f = 0; f < c; f++) d = this.graphs[f], d.valueAxis == e && \"column\" == d.type && (d.clustered ? (d.tcc = 1, d.newStack && (a = 0), d.hidden || (d.columnIndex = a, a++)) : d.hidden || (h = !0, d.tcc = 1, d.columnIndex = 0));\n\n          h && 0 === a && (a = 1);\n        }\n\n        if (\"3d\" == l) {\n          e = 1;\n\n          for (m = 0; m < c; m++) d = this.graphs[m], d.newStack && e++, d.depthCount = e, d.tcc = a;\n\n          a = e;\n        }\n      }\n\n      return a;\n    },\n    parseData: function () {\n      e.AmSerialChart.base.parseData.call(this);\n      this.parseSerialData(this.dataProvider);\n    },\n    getCategoryIndexByValue: function (a) {\n      var b = this.chartData,\n          c,\n          d;\n\n      for (d = 0; d < b.length; d++) b[d].category == a && (c = d);\n\n      return c;\n    },\n    handleCursorChange: function (a) {\n      this.updateLegendValues(a.index);\n    },\n    handleCursorZoom: function (a) {\n      this.updateScrollbar = !0;\n      this.zoom(a.start, a.end);\n    },\n    handleScrollbarZoom: function (a) {\n      this.updateScrollbar = !1;\n      this.zoom(a.start, a.end);\n    },\n    dispatchTimeZoomEvent: function () {\n      if (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime) {\n        var a = {\n          type: \"zoomed\"\n        };\n        a.startDate = new Date(this.startTime);\n        a.endDate = new Date(this.endTime);\n        a.startIndex = this.start;\n        a.endIndex = this.end;\n        this.startIndex = this.start;\n        this.endIndex = this.end;\n        this.startDate = a.startDate;\n        this.endDate = a.endDate;\n        this.prevStartTime = this.startTime;\n        this.prevEndTime = this.endTime;\n        var b = this.categoryAxis,\n            c = e.extractPeriod(b.minPeriod).period,\n            b = b.dateFormatsObject[c];\n        a.startValue = e.formatDate(a.startDate, b, this);\n        a.endValue = e.formatDate(a.endDate, b, this);\n        a.chart = this;\n        a.target = this;\n        this.fire(a.type, a);\n      }\n    },\n    dispatchIndexZoomEvent: function () {\n      if (this.prevStartIndex != this.start || this.prevEndIndex != this.end) {\n        this.startIndex = this.start;\n        this.endIndex = this.end;\n        var a = this.chartData;\n\n        if (e.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {\n          var b = {\n            chart: this,\n            target: this,\n            type: \"zoomed\"\n          };\n          b.startIndex = this.start;\n          b.endIndex = this.end;\n          b.startValue = a[this.start].category;\n          b.endValue = a[this.end].category;\n          this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));\n          this.prevStartIndex = this.start;\n          this.prevEndIndex = this.end;\n          this.fire(b.type, b);\n        }\n      }\n    },\n    updateLegendValues: function (a) {\n      var b = this.graphs,\n          c;\n\n      for (c = 0; c < b.length; c++) {\n        var d = b[c];\n        isNaN(a) ? d.currentDataItem = void 0 : d.currentDataItem = this.chartData[a].axes[d.valueAxis.id].graphs[d.id];\n      }\n\n      this.legend && this.legend.updateValues();\n    },\n    getClosestIndex: function (a, b, c, d, e, h) {\n      0 > e && (e = 0);\n      h > a.length - 1 && (h = a.length - 1);\n      var f = e + Math.round((h - e) / 2),\n          m = a[f][b];\n      if (c == m) return f;\n\n      if (1 >= h - e) {\n        if (d) return e;\n        d = a[h][b];\n        return Math.abs(a[e][b] - c) < Math.abs(d - c) ? e : h;\n      }\n\n      return c == m ? f : c < m ? this.getClosestIndex(a, b, c, d, e, f) : this.getClosestIndex(a, b, c, d, f, h);\n    },\n    zoomToIndexes: function (a, b) {\n      this.updateScrollbar = !0;\n      var c = this.chartData;\n\n      if (c) {\n        var d = c.length;\n        0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1), d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b));\n      }\n    },\n    zoomToDates: function (a, b) {\n      this.updateScrollbar = !0;\n      var c = this.chartData;\n\n      if (this.categoryAxis.equalSpacing) {\n        var d = this.getClosestIndex(c, \"time\", a.getTime(), !0, 0, c.length);\n        b = e.resetDateToMin(b, this.categoryAxis.minPeriod, 1);\n        c = this.getClosestIndex(c, \"time\", b.getTime(), !1, 0, c.length);\n        this.zoom(d, c);\n      } else this.zoom(a.getTime(), b.getTime());\n    },\n    zoomToCategoryValues: function (a, b) {\n      this.updateScrollbar = !0;\n      this.zoom(this.getCategoryIndexByValue(a), this.getCategoryIndexByValue(b));\n    },\n    formatPeriodString: function (a, b) {\n      if (b) {\n        var c = [\"value\", \"open\", \"low\", \"high\", \"close\"],\n            d = \"value open low high close average sum count\".split(\" \"),\n            g = b.valueAxis,\n            h = this.chartData,\n            f = b.numberFormatter;\n        f || (f = this.nf);\n\n        for (var m = 0; m < c.length; m++) {\n          for (var l = c[m], k = 0, p = 0, n, x, A, u, v, t = 0, q = 0, r, w, z, B, F, G = this.start; G <= this.end; G++) {\n            var y = h[G];\n\n            if (y && (y = y.axes[g.id].graphs[b.id])) {\n              if (y.values) {\n                var C = y.values[l];\n\n                if (this.rotate) {\n                  if (0 > y.x || y.x > y.graph.height) C = NaN;\n                } else if (0 > y.x || y.x > y.graph.width) C = NaN;\n\n                if (!isNaN(C)) {\n                  isNaN(n) && (n = C);\n                  x = C;\n                  if (isNaN(A) || A > C) A = C;\n                  if (isNaN(u) || u < C) u = C;\n                  v = e.getDecimals(k);\n                  var E = e.getDecimals(C),\n                      k = k + C,\n                      k = e.roundTo(k, Math.max(v, E));\n                  p++;\n                  v = k / p;\n                }\n              }\n\n              if (y.percents && (y = y.percents[l], !isNaN(y))) {\n                isNaN(r) && (r = y);\n                w = y;\n                if (isNaN(z) || z > y) z = y;\n                if (isNaN(B) || B < y) B = y;\n                F = e.getDecimals(t);\n                C = e.getDecimals(y);\n                t += y;\n                t = e.roundTo(t, Math.max(F, C));\n                q++;\n                F = t / q;\n              }\n            }\n          }\n\n          t = {\n            open: r,\n            close: w,\n            high: B,\n            low: z,\n            average: F,\n            sum: t,\n            count: q\n          };\n          a = e.formatValue(a, {\n            open: n,\n            close: x,\n            high: u,\n            low: A,\n            average: v,\n            sum: k,\n            count: p\n          }, d, f, l + \"\\\\.\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n          a = e.formatValue(a, t, d, this.pf, \"percents\\\\.\" + l + \"\\\\.\");\n        }\n      }\n\n      return a = e.cleanFromEmpty(a);\n    },\n    formatString: function (a, b, c) {\n      var d = b.graph;\n\n      if (-1 != a.indexOf(\"[[category]]\")) {\n        var g = b.serialDataItem.category;\n\n        if (this.categoryAxis.parseDates) {\n          var h = this.balloonDateFormat,\n              f = this.chartCursor;\n          f && (h = f.categoryBalloonDateFormat);\n          -1 != a.indexOf(\"[[category]]\") && (h = e.formatDate(g, h, this), -1 != h.indexOf(\"fff\") && (h = e.formatMilliseconds(h, g)), g = h);\n        }\n\n        a = a.replace(/\\[\\[category\\]\\]/g, String(g));\n      }\n\n      g = d.numberFormatter;\n      g || (g = this.nf);\n      h = b.graph.valueAxis;\n      (f = h.duration) && !isNaN(b.values.value) && (f = e.formatDuration(b.values.value, f, \"\", h.durationUnits, h.maxInterval, g), a = a.replace(RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), f));\n      \"date\" == h.type && (h = e.formatDate(new Date(b.values.value), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), a = a.replace(f, h), h = e.formatDate(new Date(b.values.open), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[open\\\\]\\\\]\", \"g\"), a = a.replace(f, h));\n      d = \"value open low high close total\".split(\" \");\n      h = this.pf;\n      a = e.formatValue(a, b.percents, d, h, \"percents\\\\.\");\n      a = e.formatValue(a, b.values, d, g, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n      a = e.formatValue(a, b.values, [\"percents\"], h);\n      -1 != a.indexOf(\"[[\") && (a = e.formatDataContextValue(a, b.dataContext));\n      -1 != a.indexOf(\"[[\") && b.graph.customData && (a = e.formatDataContextValue(a, b.graph.customData));\n      return a = e.AmSerialChart.base.formatString.call(this, a, b, c);\n    },\n    addChartScrollbar: function (a) {\n      e.callMethod(\"destroy\", [this.chartScrollbar]);\n      a && (a.chart = this, this.listenTo(a, \"zoomed\", this.handleScrollbarZoom));\n      this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight);\n      this.chartScrollbar = a;\n    },\n    removeChartScrollbar: function () {\n      e.callMethod(\"destroy\", [this.chartScrollbar]);\n      this.chartScrollbar = null;\n    },\n    handleReleaseOutside: function (a) {\n      e.AmSerialChart.base.handleReleaseOutside.call(this, a);\n      e.callMethod(\"handleReleaseOutside\", [this.chartScrollbar]);\n    },\n    update: function () {\n      e.AmSerialChart.base.update.call(this);\n      this.chartScrollbar && this.chartScrollbar.update && this.chartScrollbar.update();\n    }\n  });\n})();\n\n(function () {\n  var e = window.AmCharts;\n  e.Cuboid = e.Class({\n    construct: function (a, b, c, d, e, h, f, m, l, k, p, n, x, A, u, v, t) {\n      this.set = a.set();\n      this.container = a;\n      this.h = Math.round(c);\n      this.w = Math.round(b);\n      this.dx = d;\n      this.dy = e;\n      this.colors = h;\n      this.alpha = f;\n      this.bwidth = m;\n      this.bcolor = l;\n      this.balpha = k;\n      this.dashLength = A;\n      this.topRadius = v;\n      this.pattern = u;\n      this.rotate = x;\n      this.bcn = t;\n      x ? 0 > b && 0 === p && (p = 180) : 0 > c && 270 == p && (p = 90);\n      this.gradientRotation = p;\n      0 === d && 0 === e && (this.cornerRadius = n);\n      this.draw();\n    },\n    draw: function () {\n      var a = this.set;\n      a.clear();\n      var b = this.container,\n          c = b.chart,\n          d = this.w,\n          g = this.h,\n          h = this.dx,\n          f = this.dy,\n          m = this.colors,\n          l = this.alpha,\n          k = this.bwidth,\n          p = this.bcolor,\n          n = this.balpha,\n          x = this.gradientRotation,\n          A = this.cornerRadius,\n          u = this.dashLength,\n          v = this.pattern,\n          t = this.topRadius,\n          q = this.bcn,\n          r = m,\n          w = m;\n      \"object\" == typeof m && (r = m[0], w = m[m.length - 1]);\n      var z,\n          B,\n          F,\n          G,\n          y,\n          C,\n          E,\n          L,\n          M,\n          Q = l;\n      v && (l = 0);\n      var D,\n          H,\n          I,\n          J,\n          K = this.rotate;\n      if (0 < Math.abs(h) || 0 < Math.abs(f)) if (isNaN(t)) E = w, w = e.adjustLuminosity(r, -.2), w = e.adjustLuminosity(r, -.2), z = e.polygon(b, [0, h, d + h, d, 0], [0, f, f, 0, 0], w, l, 1, p, 0, x), 0 < n && (M = e.line(b, [0, h, d + h], [0, f, f], p, n, k, u)), B = e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], w, l, 1, p, 0, x), B.translate(h, f), 0 < n && (F = e.line(b, [h, h], [f, f + g], p, n, k, u)), G = e.polygon(b, [0, 0, h, h, 0], [0, g, g + f, f, 0], w, l, 1, p, 0, x), y = e.polygon(b, [d, d, d + h, d + h, d], [0, g, g + f, f, 0], w, l, 1, p, 0, x), 0 < n && (C = e.line(b, [d, d + h, d + h, d], [0, f, g + f, g], p, n, k, u)), w = e.adjustLuminosity(E, .2), E = e.polygon(b, [0, h, d + h, d, 0], [g, g + f, g + f, g, g], w, l, 1, p, 0, x), 0 < n && (L = e.line(b, [0, h, d + h], [g, g + f, g + f], p, n, k, u));else {\n        var N, O, P;\n        K ? (N = g / 2, w = h / 2, P = g / 2, O = d + h / 2, H = Math.abs(g / 2), D = Math.abs(h / 2)) : (w = d / 2, N = f / 2, O = d / 2, P = g + f / 2 + 1, D = Math.abs(d / 2), H = Math.abs(f / 2));\n        I = D * t;\n        J = H * t;\n        .1 < D && .1 < D && (z = e.circle(b, D, r, l, k, p, n, !1, H), z.translate(w, N));\n        .1 < I && .1 < I && (E = e.circle(b, I, e.adjustLuminosity(r, .5), l, k, p, n, !1, J), E.translate(O, P));\n      }\n      l = Q;\n      1 > Math.abs(g) && (g = 0);\n      1 > Math.abs(d) && (d = 0);\n      !isNaN(t) && (0 < Math.abs(h) || 0 < Math.abs(f)) ? (m = [r], m = {\n        fill: m,\n        stroke: p,\n        \"stroke-width\": k,\n        \"stroke-opacity\": n,\n        \"fill-opacity\": l\n      }, K ? (l = \"M0,0 L\" + d + \",\" + (g / 2 - g / 2 * t), k = \" B\", 0 < d && (k = \" A\"), e.VML ? (l += k + Math.round(d - I) + \",\" + Math.round(g / 2 - J) + \",\" + Math.round(d + I) + \",\" + Math.round(g / 2 + J) + \",\" + d + \",0,\" + d + \",\" + g, l = l + (\" L0,\" + g) + (k + Math.round(-D) + \",\" + Math.round(g / 2 - H) + \",\" + Math.round(D) + \",\" + Math.round(g / 2 + H) + \",0,\" + g + \",0,0\")) : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + d + \",\" + (g - g / 2 * (1 - t)) + \"L0,\" + g, l += \"A\" + D + \",\" + H + \",0,0,1,0,0\"), D = 90) : (k = d / 2 - d / 2 * t, l = \"M0,0 L\" + k + \",\" + g, e.VML ? (l = \"M0,0 L\" + k + \",\" + g, k = \" B\", 0 > g && (k = \" A\"), l += k + Math.round(d / 2 - I) + \",\" + Math.round(g - J) + \",\" + Math.round(d / 2 + I) + \",\" + Math.round(g + J) + \",0,\" + g + \",\" + d + \",\" + g, l += \" L\" + d + \",0\", l += k + Math.round(d / 2 + D) + \",\" + Math.round(H) + \",\" + Math.round(d / 2 - D) + \",\" + Math.round(-H) + \",\" + d + \",0,0,0\") : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + (d - d / 2 * (1 - t)) + \",\" + g + \"L\" + d + \",0\", l += \"A\" + D + \",\" + H + \",0,0,1,0,0\"), D = 180), b = b.path(l).attr(m), b.gradient(\"linearGradient\", [r, e.adjustLuminosity(r, -.3), e.adjustLuminosity(r, -.3), r], D), K ? b.translate(h / 2, 0) : b.translate(0, f / 2)) : b = 0 === g ? e.line(b, [0, d], [0, 0], p, n, k, u) : 0 === d ? e.line(b, [0, 0], [0, g], p, n, k, u) : 0 < A ? e.rect(b, d, g, m, l, k, p, n, A, x, u) : e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], m, l, k, p, n, x, !1, u);\n      d = isNaN(t) ? 0 > g ? [z, M, B, F, G, y, C, E, L, b] : [E, L, B, F, G, y, z, M, C, b] : K ? 0 < d ? [z, b, E] : [E, b, z] : 0 > g ? [z, b, E] : [E, b, z];\n      e.setCN(c, b, q + \"front\");\n      e.setCN(c, B, q + \"back\");\n      e.setCN(c, E, q + \"top\");\n      e.setCN(c, z, q + \"bottom\");\n      e.setCN(c, G, q + \"left\");\n      e.setCN(c, y, q + \"right\");\n\n      for (z = 0; z < d.length; z++) if (B = d[z]) a.push(B), e.setCN(c, B, q + \"element\");\n\n      v && b.pattern(v);\n    },\n    width: function (a) {\n      isNaN(a) && (a = 0);\n      this.w = Math.round(a);\n      this.draw();\n    },\n    height: function (a) {\n      isNaN(a) && (a = 0);\n      this.h = Math.round(a);\n      this.draw();\n    },\n    animateHeight: function (a, b) {\n      var c = this;\n      c.easing = b;\n      c.totalFrames = Math.round(1E3 * a / e.updateRate);\n      c.rh = c.h;\n      c.frame = 0;\n      c.height(1);\n      setTimeout(function () {\n        c.updateHeight.call(c);\n      }, e.updateRate);\n    },\n    updateHeight: function () {\n      var a = this;\n      a.frame++;\n      var b = a.totalFrames;\n      a.frame <= b && (b = a.easing(0, a.frame, 1, a.rh - 1, b), a.height(b), setTimeout(function () {\n        a.updateHeight.call(a);\n      }, e.updateRate));\n    },\n    animateWidth: function (a, b) {\n      var c = this;\n      c.easing = b;\n      c.totalFrames = Math.round(1E3 * a / e.updateRate);\n      c.rw = c.w;\n      c.frame = 0;\n      c.width(1);\n      setTimeout(function () {\n        c.updateWidth.call(c);\n      }, e.updateRate);\n    },\n    updateWidth: function () {\n      var a = this;\n      a.frame++;\n      var b = a.totalFrames;\n      a.frame <= b && (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), setTimeout(function () {\n        a.updateWidth.call(a);\n      }, e.updateRate));\n    }\n  });\n})();\n\n(function () {\n  var e = window.AmCharts;\n  e.CategoryAxis = e.Class({\n    inherits: e.AxisBase,\n    construct: function (a) {\n      this.cname = \"CategoryAxis\";\n      e.CategoryAxis.base.construct.call(this, a);\n      this.minPeriod = \"DD\";\n      this.equalSpacing = this.parseDates = !1;\n      this.position = \"bottom\";\n      this.startOnAxis = !1;\n      this.firstDayOfWeek = 1;\n      this.gridPosition = \"middle\";\n      this.markPeriodChange = this.boldPeriodBeginning = !0;\n      this.safeDistance = 30;\n      this.centerLabelOnFullPeriod = !0;\n      e.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      e.CategoryAxis.base.draw.call(this);\n      this.generateDFObject();\n      var a = this.chart.chartData;\n      this.data = a;\n\n      if (e.ifArray(a)) {\n        var b,\n            c = this.chart;\n        \"scrollbar\" != this.id ? (e.setCN(c, this.set, \"category-axis\"), e.setCN(c, this.labelsSet, \"category-axis\"), e.setCN(c, this.axisLine.axisSet, \"category-axis\")) : this.bcn = this.id + \"-\";\n        var d = this.start,\n            g = this.labelFrequency,\n            h = 0,\n            f = this.end - d + 1,\n            m = this.gridCountR,\n            l = this.showFirstLabel,\n            k = this.showLastLabel,\n            p,\n            n = \"\",\n            n = e.extractPeriod(this.minPeriod),\n            x = e.getPeriodDuration(n.period, n.count),\n            A,\n            u,\n            v,\n            t,\n            q;\n        A = this.rotate;\n        b = this.firstDayOfWeek;\n        p = this.boldPeriodBeginning;\n        var r = e.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * x), this.minPeriod, 1, b).getTime();\n        this.firstTime = c.firstTime;\n        this.endTime > r && (this.endTime = r);\n        q = this.minorGridEnabled;\n        var w,\n            r = this.gridAlpha;\n        if (this.parseDates && !this.equalSpacing) this.lastTime = a[a.length - 1].time, this.maxTime = e.resetDateToMin(new Date(this.lastTime + 1.05 * x), this.minPeriod, 1, b).getTime(), this.timeDifference = this.endTime - this.startTime, this.parseDatesDraw();else if (!this.parseDates) {\n          if (this.cellWidth = this.getStepWidth(f), f < m && (m = f), h += this.start, this.stepWidth = this.getStepWidth(f), 0 < m) {\n            m = Math.floor(f / m);\n            w = this.chooseMinorFrequency(m);\n            f = h;\n            f / 2 == Math.round(f / 2) && f--;\n            0 > f && (f = 0);\n            var z = 0;\n            this.end - f + 1 >= this.autoRotateCount && (this.labelRotation = this.autoRotateAngle);\n\n            for (b = f; b <= this.end + 2; b++) {\n              p = !1;\n              0 <= b && b < this.data.length ? (u = this.data[b], n = u.category, p = u.forceShow) : n = \"\";\n              if (q && !isNaN(w)) {\n                if (b / w == Math.round(b / w) || p) b / m == Math.round(b / m) || p || (this.gridAlpha = this.minorGridAlpha, n = void 0);else continue;\n              } else if (b / m != Math.round(b / m) && !p) continue;\n              f = this.getCoordinate(b - h);\n              v = 0;\n              \"start\" == this.gridPosition && (f -= this.cellWidth / 2, v = this.cellWidth / 2);\n              p = !0;\n              a = v;\n              \"start\" == this.tickPosition && (a = 0, p = !1, v = 0);\n              if (b == d && !l || b == this.end && !k) n = void 0;\n              Math.round(z / g) != z / g && (n = void 0);\n              z++;\n              var B = this.cellWidth;\n              A && (B = NaN);\n              this.labelFunction && u && (n = this.labelFunction(n, u, this));\n              n = e.fixBrakes(n);\n              x = !1;\n              this.boldLabels && (x = !0);\n              b > this.end && \"start\" == this.tickPosition && (n = \" \");\n              v = new this.axisItemRenderer(this, f, n, p, B, v, void 0, x, a, !1, u.labelColor, u.className);\n              v.serialDataItem = u;\n              this.pushAxisItem(v);\n              this.gridAlpha = r;\n            }\n          }\n        } else if (this.parseDates && this.equalSpacing) {\n          h = this.start;\n          this.startTime = this.data[this.start].time;\n          this.endTime = this.data[this.end].time;\n          this.timeDifference = this.endTime - this.startTime;\n          d = this.choosePeriod(0);\n          g = d.period;\n          A = d.count;\n          a = e.getPeriodDuration(g, A);\n          a < x && (g = n.period, A = n.count, a = x);\n          u = g;\n          \"WW\" == u && (u = \"DD\");\n          this.stepWidth = this.getStepWidth(f);\n          m = Math.ceil(this.timeDifference / a) + 1;\n          n = e.resetDateToMin(new Date(this.startTime - a), g, A, b).getTime();\n          this.cellWidth = this.getStepWidth(f);\n          f = Math.round(n / a);\n          d = -1;\n          f / 2 == Math.round(f / 2) && (d = -2, n -= a);\n          f = this.start;\n          f / 2 == Math.round(f / 2) && f--;\n          0 > f && (f = 0);\n          a = this.end + 2;\n          a >= this.data.length && (a = this.data.length);\n          B = !1;\n          B = !l;\n          this.previousPos = -1E3;\n          20 < this.labelRotation && (this.safeDistance = 5);\n          var F = f;\n\n          if (this.data[f].time != e.resetDateToMin(new Date(this.data[f].time), g, A, b).getTime()) {\n            var x = 0,\n                G = n;\n\n            for (b = f; b < a; b++) t = this.data[b].time, this.checkPeriodChange(g, A, t, G) && (x++, 2 <= x && (F = b, b = a), G = t);\n          }\n\n          q && 1 < A && (w = this.chooseMinorFrequency(A), e.getPeriodDuration(g, w));\n          if (0 < this.gridCountR) for (b = f; b < a; b++) if (t = this.data[b].time, this.checkPeriodChange(g, A, t, n) && b >= F) {\n            f = this.getCoordinate(b - this.start);\n            q = !1;\n            this.nextPeriod[u] && (q = this.checkPeriodChange(this.nextPeriod[u], 1, t, n, u));\n            x = !1;\n            q && this.markPeriodChange ? (q = this.dateFormatsObject[this.nextPeriod[u]], x = !0) : q = this.dateFormatsObject[u];\n            n = e.formatDate(new Date(t), q, c);\n            if (b == d && !l || b == m && !k) n = \" \";\n            B ? B = !1 : (p || (x = !1), f - this.previousPos > this.safeDistance * Math.cos(this.labelRotation * Math.PI / 180) && (this.labelFunction && (n = this.labelFunction(n, new Date(t), this, g, A, v)), this.boldLabels && (x = !0), v = new this.axisItemRenderer(this, f, n, void 0, void 0, void 0, void 0, x), q = v.graphics(), this.pushAxisItem(v), q = q.getBBox().width, e.isModern || (q -= f), this.previousPos = f + q));\n            v = n = t;\n          } else isNaN(w) || (this.checkPeriodChange(g, w, t, z) && (this.gridAlpha = this.minorGridAlpha, f = this.getCoordinate(b - this.start), q = new this.axisItemRenderer(this, f), this.pushAxisItem(q), z = t), this.gridAlpha = r);\n        }\n\n        for (b = 0; b < this.data.length; b++) if (l = this.data[b]) k = this.parseDates && !this.equalSpacing ? Math.round((l.time - this.startTime) * this.stepWidth + this.cellWidth / 2) : this.getCoordinate(b - h), l.x[this.id] = k;\n\n        l = this.guides.length;\n\n        for (b = 0; b < l; b++) k = this.guides[b], q = p = q = r = d = NaN, w = k.above, k.toCategory && (p = c.getCategoryIndexByValue(k.toCategory), isNaN(p) || (d = this.getCoordinate(p - h), k.expand && (d += this.cellWidth / 2), v = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, k), this.pushAxisItem(v, w))), k.category && (q = c.getCategoryIndexByValue(k.category), isNaN(q) || (r = this.getCoordinate(q - h), k.expand && (r -= this.cellWidth / 2), q = (d - r) / 2, v = new this.axisItemRenderer(this, r, k.label, !0, NaN, q, k), this.pushAxisItem(v, w))), q = c.dataDateFormat, k.toDate && (k.toDate = e.getDate(k.toDate, q, this.minPeriod), this.equalSpacing ? (p = c.getClosestIndex(this.data, \"time\", k.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(p) || (d = this.getCoordinate(p - h))) : d = (k.toDate.getTime() - this.startTime) * this.stepWidth, v = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, k), this.pushAxisItem(v, w)), k.date && (k.date = e.getDate(k.date, q, this.minPeriod), this.equalSpacing ? (q = c.getClosestIndex(this.data, \"time\", k.date.getTime(), !1, 0, this.data.length - 1), isNaN(q) || (r = this.getCoordinate(q - h))) : r = (k.date.getTime() - this.startTime) * this.stepWidth, q = (d - r) / 2, p = !0, k.toDate && (p = !1), v = \"H\" == this.orientation ? new this.axisItemRenderer(this, r, k.label, p, 2 * q, NaN, k) : new this.axisItemRenderer(this, r, k.label, !1, NaN, q, k), this.pushAxisItem(v, w)), (0 < d || 0 < r) && (d < this.width || r < this.width) && (d = new this.guideFillRenderer(this, r, d, k), r = d.graphics(), this.pushAxisItem(d, w), k.graphics = r, r.index = b, k.balloonText && this.addEventListeners(r, k));\n      }\n\n      this.axisCreated = !0;\n      c = this.x;\n      h = this.y;\n      this.set.translate(c, h);\n      this.labelsSet.translate(c, h);\n      this.positionTitle();\n      (c = this.axisLine.set) && c.toFront();\n      c = this.getBBox().height;\n      2 < c - this.previousHeight && this.autoWrap && !this.parseDates && (this.axisCreated = this.chart.marginsUpdated = !1);\n      this.previousHeight = c;\n    },\n    xToIndex: function (a) {\n      var b = this.data,\n          c = this.chart,\n          d = c.rotate,\n          g = this.stepWidth;\n      this.parseDates && !this.equalSpacing ? (a = this.startTime + Math.round(a / g) - this.minDuration() / 2, c = c.getClosestIndex(b, \"time\", a, !1, this.start, this.end + 1)) : (this.startOnAxis || (a -= g / 2), c = this.start + Math.round(a / g));\n      var c = e.fitToBounds(c, 0, b.length - 1),\n          h;\n      b[c] && (h = b[c].x[this.id]);\n      d ? h > this.height + 1 && c-- : h > this.width + 1 && c--;\n      0 > h && c++;\n      return c = e.fitToBounds(c, 0, b.length - 1);\n    },\n    dateToCoordinate: function (a) {\n      return this.parseDates && !this.equalSpacing ? (a.getTime() - this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, \"time\", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN;\n    },\n    categoryToCoordinate: function (a) {\n      return this.chart ? (a = this.chart.getCategoryIndexByValue(a), this.getCoordinate(a - this.start)) : NaN;\n    },\n    coordinateToDate: function (a) {\n      return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth);\n    },\n    getCoordinate: function (a) {\n      a *= this.stepWidth;\n      this.startOnAxis || (a += this.stepWidth / 2);\n      return Math.round(a);\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}