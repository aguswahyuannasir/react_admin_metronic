{"ast":null,"code":"/* Javascript plotting library for jQuery, version 0.8.3.\n\nCopyright (c) 2007-2014 IOLA and Ole Laursen.\nLicensed under the MIT license.\n\n*/\n(function ($) {\n  var REDRAW_ATTEMPTS = 10;\n  var REDRAW_SHRINK = .95;\n\n  function init(plot) {\n    var canvas = null,\n        target = null,\n        options = null,\n        maxRadius = null,\n        centerLeft = null,\n        centerTop = null,\n        processed = false,\n        ctx = null;\n    var highlights = [];\n    plot.hooks.processOptions.push(function (plot, options) {\n      if (options.series.pie.show) {\n        options.grid.show = false;\n\n        if (options.series.pie.label.show == \"auto\") {\n          if (options.legend.show) {\n            options.series.pie.label.show = false;\n          } else {\n            options.series.pie.label.show = true;\n          }\n        }\n\n        if (options.series.pie.radius == \"auto\") {\n          if (options.series.pie.label.show) {\n            options.series.pie.radius = 3 / 4;\n          } else {\n            options.series.pie.radius = 1;\n          }\n        }\n\n        if (options.series.pie.tilt > 1) {\n          options.series.pie.tilt = 1;\n        } else if (options.series.pie.tilt < 0) {\n          options.series.pie.tilt = 0;\n        }\n      }\n    });\n    plot.hooks.bindEvents.push(function (plot, eventHolder) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        if (options.grid.hoverable) {\n          eventHolder.unbind(\"mousemove\").mousemove(onMouseMove);\n        }\n\n        if (options.grid.clickable) {\n          eventHolder.unbind(\"click\").click(onClick);\n        }\n      }\n    });\n    plot.hooks.processDatapoints.push(function (plot, series, data, datapoints) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        processDatapoints(plot, series, data, datapoints);\n      }\n    });\n    plot.hooks.drawOverlay.push(function (plot, octx) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        drawOverlay(plot, octx);\n      }\n    });\n    plot.hooks.draw.push(function (plot, newCtx) {\n      var options = plot.getOptions();\n\n      if (options.series.pie.show) {\n        draw(plot, newCtx);\n      }\n    });\n\n    function processDatapoints(plot, series, datapoints) {\n      if (!processed) {\n        processed = true;\n        canvas = plot.getCanvas();\n        target = $(canvas).parent();\n        options = plot.getOptions();\n        plot.setData(combine(plot.getData()));\n      }\n    }\n\n    function combine(data) {\n      var total = 0,\n          combined = 0,\n          numCombined = 0,\n          color = options.series.pie.combine.color,\n          newdata = [];\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data;\n\n        if ($.isArray(value) && value.length == 1) {\n          value = value[0];\n        }\n\n        if ($.isArray(value)) {\n          if (!isNaN(parseFloat(value[1])) && isFinite(value[1])) {\n            value[1] = +value[1];\n          } else {\n            value[1] = 0;\n          }\n        } else if (!isNaN(parseFloat(value)) && isFinite(value)) {\n          value = [1, +value];\n        } else {\n          value = [1, 0];\n        }\n\n        data[i].data = [value];\n      }\n\n      for (var i = 0; i < data.length; ++i) {\n        total += data[i].data[0][1];\n      }\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data[0][1];\n\n        if (value / total <= options.series.pie.combine.threshold) {\n          combined += value;\n          numCombined++;\n\n          if (!color) {\n            color = data[i].color;\n          }\n        }\n      }\n\n      for (var i = 0; i < data.length; ++i) {\n        var value = data[i].data[0][1];\n\n        if (numCombined < 2 || value / total > options.series.pie.combine.threshold) {\n          newdata.push($.extend(data[i], {\n            data: [[1, value]],\n            color: data[i].color,\n            label: data[i].label,\n            angle: value * Math.PI * 2 / total,\n            percent: value / (total / 100)\n          }));\n        }\n      }\n\n      if (numCombined > 1) {\n        newdata.push({\n          data: [[1, combined]],\n          color: color,\n          label: options.series.pie.combine.label,\n          angle: combined * Math.PI * 2 / total,\n          percent: combined / (total / 100)\n        });\n      }\n\n      return newdata;\n    }\n\n    function draw(plot, newCtx) {\n      if (!target) {\n        return;\n      }\n\n      var canvasWidth = plot.getPlaceholder().width(),\n          canvasHeight = plot.getPlaceholder().height(),\n          legendWidth = target.children().filter(\".legend\").children().width() || 0;\n      ctx = newCtx;\n      processed = false;\n      maxRadius = Math.min(canvasWidth, canvasHeight / options.series.pie.tilt) / 2;\n      centerTop = canvasHeight / 2 + options.series.pie.offset.top;\n      centerLeft = canvasWidth / 2;\n\n      if (options.series.pie.offset.left == \"auto\") {\n        if (options.legend.position.match(\"w\")) {\n          centerLeft += legendWidth / 2;\n        } else {\n          centerLeft -= legendWidth / 2;\n        }\n\n        if (centerLeft < maxRadius) {\n          centerLeft = maxRadius;\n        } else if (centerLeft > canvasWidth - maxRadius) {\n          centerLeft = canvasWidth - maxRadius;\n        }\n      } else {\n        centerLeft += options.series.pie.offset.left;\n      }\n\n      var slices = plot.getData(),\n          attempts = 0;\n\n      do {\n        if (attempts > 0) {\n          maxRadius *= REDRAW_SHRINK;\n        }\n\n        attempts += 1;\n        clear();\n\n        if (options.series.pie.tilt <= .8) {\n          drawShadow();\n        }\n      } while (!drawPie() && attempts < REDRAW_ATTEMPTS);\n\n      if (attempts >= REDRAW_ATTEMPTS) {\n        clear();\n        target.prepend(\"<div class='error'>Could not draw pie with labels contained inside canvas</div>\");\n      }\n\n      if (plot.setSeries && plot.insertLegend) {\n        plot.setSeries(slices);\n        plot.insertLegend();\n      }\n\n      function clear() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        target.children().filter(\".pieLabel, .pieLabelBackground\").remove();\n      }\n\n      function drawShadow() {\n        var shadowLeft = options.series.pie.shadow.left;\n        var shadowTop = options.series.pie.shadow.top;\n        var edge = 10;\n        var alpha = options.series.pie.shadow.alpha;\n        var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n\n        if (radius >= canvasWidth / 2 - shadowLeft || radius * options.series.pie.tilt >= canvasHeight / 2 - shadowTop || radius <= edge) {\n          return;\n        }\n\n        ctx.save();\n        ctx.translate(shadowLeft, shadowTop);\n        ctx.globalAlpha = alpha;\n        ctx.fillStyle = \"#000\";\n        ctx.translate(centerLeft, centerTop);\n        ctx.scale(1, options.series.pie.tilt);\n\n        for (var i = 1; i <= edge; i++) {\n          ctx.beginPath();\n          ctx.arc(0, 0, radius, 0, Math.PI * 2, false);\n          ctx.fill();\n          radius -= i;\n        }\n\n        ctx.restore();\n      }\n\n      function drawPie() {\n        var startAngle = Math.PI * options.series.pie.startAngle;\n        var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n        ctx.save();\n        ctx.translate(centerLeft, centerTop);\n        ctx.scale(1, options.series.pie.tilt);\n        ctx.save();\n        var currentAngle = startAngle;\n\n        for (var i = 0; i < slices.length; ++i) {\n          slices[i].startAngle = currentAngle;\n          drawSlice(slices[i].angle, slices[i].color, true);\n        }\n\n        ctx.restore();\n\n        if (options.series.pie.stroke.width > 0) {\n          ctx.save();\n          ctx.lineWidth = options.series.pie.stroke.width;\n          currentAngle = startAngle;\n\n          for (var i = 0; i < slices.length; ++i) {\n            drawSlice(slices[i].angle, options.series.pie.stroke.color, false);\n          }\n\n          ctx.restore();\n        }\n\n        drawDonutHole(ctx);\n        ctx.restore();\n\n        if (options.series.pie.label.show) {\n          return drawLabels();\n        } else return true;\n\n        function drawSlice(angle, color, fill) {\n          if (angle <= 0 || isNaN(angle)) {\n            return;\n          }\n\n          if (fill) {\n            ctx.fillStyle = color;\n          } else {\n            ctx.strokeStyle = color;\n            ctx.lineJoin = \"round\";\n          }\n\n          ctx.beginPath();\n\n          if (Math.abs(angle - Math.PI * 2) > 1e-9) {\n            ctx.moveTo(0, 0);\n          }\n\n          ctx.arc(0, 0, radius, currentAngle, currentAngle + angle / 2, false);\n          ctx.arc(0, 0, radius, currentAngle + angle / 2, currentAngle + angle, false);\n          ctx.closePath();\n          currentAngle += angle;\n\n          if (fill) {\n            ctx.fill();\n          } else {\n            ctx.stroke();\n          }\n        }\n\n        function drawLabels() {\n          var currentAngle = startAngle;\n          var radius = options.series.pie.label.radius > 1 ? options.series.pie.label.radius : maxRadius * options.series.pie.label.radius;\n\n          for (var i = 0; i < slices.length; ++i) {\n            if (slices[i].percent >= options.series.pie.label.threshold * 100) {\n              if (!drawLabel(slices[i], currentAngle, i)) {\n                return false;\n              }\n            }\n\n            currentAngle += slices[i].angle;\n          }\n\n          return true;\n\n          function drawLabel(slice, startAngle, index) {\n            if (slice.data[0][1] == 0) {\n              return true;\n            }\n\n            var lf = options.legend.labelFormatter,\n                text,\n                plf = options.series.pie.label.formatter;\n\n            if (lf) {\n              text = lf(slice.label, slice);\n            } else {\n              text = slice.label;\n            }\n\n            if (plf) {\n              text = plf(text, slice);\n            }\n\n            var halfAngle = (startAngle + slice.angle + startAngle) / 2;\n            var x = centerLeft + Math.round(Math.cos(halfAngle) * radius);\n            var y = centerTop + Math.round(Math.sin(halfAngle) * radius) * options.series.pie.tilt;\n            var html = \"<span class='pieLabel' id='pieLabel\" + index + \"' style='position:absolute;top:\" + y + \"px;left:\" + x + \"px;'>\" + text + \"</span>\";\n            target.append(html);\n            var label = target.children(\"#pieLabel\" + index);\n            var labelTop = y - label.height() / 2;\n            var labelLeft = x - label.width() / 2;\n            label.css(\"top\", labelTop);\n            label.css(\"left\", labelLeft);\n\n            if (0 - labelTop > 0 || 0 - labelLeft > 0 || canvasHeight - (labelTop + label.height()) < 0 || canvasWidth - (labelLeft + label.width()) < 0) {\n              return false;\n            }\n\n            if (options.series.pie.label.background.opacity != 0) {\n              var c = options.series.pie.label.background.color;\n\n              if (c == null) {\n                c = slice.color;\n              }\n\n              var pos = \"top:\" + labelTop + \"px;left:\" + labelLeft + \"px;\";\n              $(\"<div class='pieLabelBackground' style='position:absolute;width:\" + label.width() + \"px;height:\" + label.height() + \"px;\" + pos + \"background-color:\" + c + \";'></div>\").css(\"opacity\", options.series.pie.label.background.opacity).insertBefore(label);\n            }\n\n            return true;\n          }\n        }\n      }\n    }\n\n    function drawDonutHole(layer) {\n      if (options.series.pie.innerRadius > 0) {\n        layer.save();\n        var innerRadius = options.series.pie.innerRadius > 1 ? options.series.pie.innerRadius : maxRadius * options.series.pie.innerRadius;\n        layer.globalCompositeOperation = \"destination-out\";\n        layer.beginPath();\n        layer.fillStyle = options.series.pie.stroke.color;\n        layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n        layer.fill();\n        layer.closePath();\n        layer.restore();\n        layer.save();\n        layer.beginPath();\n        layer.strokeStyle = options.series.pie.stroke.color;\n        layer.arc(0, 0, innerRadius, 0, Math.PI * 2, false);\n        layer.stroke();\n        layer.closePath();\n        layer.restore();\n      }\n    }\n\n    function isPointInPoly(poly, pt) {\n      for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) (poly[i][1] <= pt[1] && pt[1] < poly[j][1] || poly[j][1] <= pt[1] && pt[1] < poly[i][1]) && pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0] && (c = !c);\n\n      return c;\n    }\n\n    function findNearbySlice(mouseX, mouseY) {\n      var slices = plot.getData(),\n          options = plot.getOptions(),\n          radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius,\n          x,\n          y;\n\n      for (var i = 0; i < slices.length; ++i) {\n        var s = slices[i];\n\n        if (s.pie.show) {\n          ctx.save();\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.arc(0, 0, radius, s.startAngle, s.startAngle + s.angle / 2, false);\n          ctx.arc(0, 0, radius, s.startAngle + s.angle / 2, s.startAngle + s.angle, false);\n          ctx.closePath();\n          x = mouseX - centerLeft;\n          y = mouseY - centerTop;\n\n          if (ctx.isPointInPath) {\n            if (ctx.isPointInPath(mouseX - centerLeft, mouseY - centerTop)) {\n              ctx.restore();\n              return {\n                datapoint: [s.percent, s.data],\n                dataIndex: 0,\n                series: s,\n                seriesIndex: i\n              };\n            }\n          } else {\n            var p1X = radius * Math.cos(s.startAngle),\n                p1Y = radius * Math.sin(s.startAngle),\n                p2X = radius * Math.cos(s.startAngle + s.angle / 4),\n                p2Y = radius * Math.sin(s.startAngle + s.angle / 4),\n                p3X = radius * Math.cos(s.startAngle + s.angle / 2),\n                p3Y = radius * Math.sin(s.startAngle + s.angle / 2),\n                p4X = radius * Math.cos(s.startAngle + s.angle / 1.5),\n                p4Y = radius * Math.sin(s.startAngle + s.angle / 1.5),\n                p5X = radius * Math.cos(s.startAngle + s.angle),\n                p5Y = radius * Math.sin(s.startAngle + s.angle),\n                arrPoly = [[0, 0], [p1X, p1Y], [p2X, p2Y], [p3X, p3Y], [p4X, p4Y], [p5X, p5Y]],\n                arrPoint = [x, y];\n\n            if (isPointInPoly(arrPoly, arrPoint)) {\n              ctx.restore();\n              return {\n                datapoint: [s.percent, s.data],\n                dataIndex: 0,\n                series: s,\n                seriesIndex: i\n              };\n            }\n          }\n\n          ctx.restore();\n        }\n      }\n\n      return null;\n    }\n\n    function onMouseMove(e) {\n      triggerClickHoverEvent(\"plothover\", e);\n    }\n\n    function onClick(e) {\n      triggerClickHoverEvent(\"plotclick\", e);\n    }\n\n    function triggerClickHoverEvent(eventname, e) {\n      var offset = plot.offset();\n      var canvasX = parseInt(e.pageX - offset.left);\n      var canvasY = parseInt(e.pageY - offset.top);\n      var item = findNearbySlice(canvasX, canvasY);\n\n      if (options.grid.autoHighlight) {\n        for (var i = 0; i < highlights.length; ++i) {\n          var h = highlights[i];\n\n          if (h.auto == eventname && !(item && h.series == item.series)) {\n            unhighlight(h.series);\n          }\n        }\n      }\n\n      if (item) {\n        highlight(item.series, eventname);\n      }\n\n      var pos = {\n        pageX: e.pageX,\n        pageY: e.pageY\n      };\n      target.trigger(eventname, [pos, item]);\n    }\n\n    function highlight(s, auto) {\n      var i = indexOfHighlight(s);\n\n      if (i == -1) {\n        highlights.push({\n          series: s,\n          auto: auto\n        });\n        plot.triggerRedrawOverlay();\n      } else if (!auto) {\n        highlights[i].auto = false;\n      }\n    }\n\n    function unhighlight(s) {\n      if (s == null) {\n        highlights = [];\n        plot.triggerRedrawOverlay();\n      }\n\n      var i = indexOfHighlight(s);\n\n      if (i != -1) {\n        highlights.splice(i, 1);\n        plot.triggerRedrawOverlay();\n      }\n    }\n\n    function indexOfHighlight(s) {\n      for (var i = 0; i < highlights.length; ++i) {\n        var h = highlights[i];\n        if (h.series == s) return i;\n      }\n\n      return -1;\n    }\n\n    function drawOverlay(plot, octx) {\n      var options = plot.getOptions();\n      var radius = options.series.pie.radius > 1 ? options.series.pie.radius : maxRadius * options.series.pie.radius;\n      octx.save();\n      octx.translate(centerLeft, centerTop);\n      octx.scale(1, options.series.pie.tilt);\n\n      for (var i = 0; i < highlights.length; ++i) {\n        drawHighlight(highlights[i].series);\n      }\n\n      drawDonutHole(octx);\n      octx.restore();\n\n      function drawHighlight(series) {\n        if (series.angle <= 0 || isNaN(series.angle)) {\n          return;\n        }\n\n        octx.fillStyle = \"rgba(255, 255, 255, \" + options.series.pie.highlight.opacity + \")\";\n        octx.beginPath();\n\n        if (Math.abs(series.angle - Math.PI * 2) > 1e-9) {\n          octx.moveTo(0, 0);\n        }\n\n        octx.arc(0, 0, radius, series.startAngle, series.startAngle + series.angle / 2, false);\n        octx.arc(0, 0, radius, series.startAngle + series.angle / 2, series.startAngle + series.angle, false);\n        octx.closePath();\n        octx.fill();\n      }\n    }\n  }\n\n  var options = {\n    series: {\n      pie: {\n        show: false,\n        radius: \"auto\",\n        innerRadius: 0,\n        startAngle: 3 / 2,\n        tilt: 1,\n        shadow: {\n          left: 5,\n          top: 15,\n          alpha: .02\n        },\n        offset: {\n          top: 0,\n          left: \"auto\"\n        },\n        stroke: {\n          color: \"#fff\",\n          width: 1\n        },\n        label: {\n          show: \"auto\",\n          formatter: function (label, slice) {\n            return \"<div style='font-size:x-small;text-align:center;padding:2px;color:\" + slice.color + \";'>\" + label + \"<br/>\" + Math.round(slice.percent) + \"%</div>\";\n          },\n          radius: 1,\n          background: {\n            color: null,\n            opacity: 0\n          },\n          threshold: 0\n        },\n        combine: {\n          threshold: -1,\n          color: null,\n          label: \"Other\"\n        },\n        highlight: {\n          opacity: .5\n        }\n      }\n    }\n  };\n  $.plot.plugins.push({\n    init: init,\n    options: options,\n    name: \"pie\",\n    version: \"1.1\"\n  });\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}